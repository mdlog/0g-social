// app/api/og-chat/route.ts
import { NextRequest, NextResponse } from "next/server";
import { ethers } from "ethers";
import {
  createZGComputeNetworkBroker,
  type ZGComputeNetworkBroker,
} from "@0glabs/0g-serving-broker";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

// --- Konfigurasi via ENV ---
const {
  OG_PRIVATE_KEY,           // private key wallet EVM untuk 0G
  OG_RPC_URL = "https://evmrpc-testnet.0g.ai", // RPC 0G Galileo
  OG_PROVIDER_ADDRESS,      // optional: alamat provider 0G Compute default
  OG_MIN_BALANCE = "0.05",  // saldo minimum (OG) sebelum request
  OG_TOPUP_AMOUNT = "0.1",  // jumlah deposit ketika saldo < minimum
} = process.env;

// Helper: inisialisasi broker sekali per request
async function initBroker(): Promise<ZGComputeNetworkBroker> {
  if (!OG_PRIVATE_KEY) throw new Error("Missing env OG_PRIVATE_KEY");
  const provider = new ethers.JsonRpcProvider(OG_RPC_URL);
  const wallet = new ethers.Wallet(OG_PRIVATE_KEY, provider);
  return createZGComputeNetworkBroker(wallet);
}

// Helper: pastikan saldo cukup; auto-topup bila kurang
async function ensureBalance(broker: ZGComputeNetworkBroker) {
  const acct = await broker.ledger.getLedger();
  const total = Number(acct.totalbalance.toString()); // saldo OG (string numeric)
  const min = Number(OG_MIN_BALANCE);
  if (Number.isNaN(total)) throw new Error("Cannot parse ledger balance");
  if (total < min) {
    await broker.ledger.depositFund(OG_TOPUP_AMOUNT); // isi dana prabayar
  }
}

// Helper: pilih provider & model
async function resolveService(
  broker: ZGComputeNetworkBroker,
  preferredProvider?: string,
  preferredModel?: string
) {
  // Jika user kirim provider, gunakan itu; kalau tidak, pilih pertama yang cocok
  if (preferredProvider) {
    const meta = await broker.inference.getServiceMetadata(preferredProvider);
    if (preferredModel && meta.model !== preferredModel) {
      // Jika user memaksa model berbeda, tetap pakai model dari metadata provider
      // (kebanyakan provider expose satu model per endpoint)
    }
    return { providerAddress: preferredProvider, endpoint: meta.endpoint, model: meta.model };
  }

  const list = await broker.inference.listService();
  if (!list.length) throw new Error("No 0G Compute services available");
  // Contoh: preferensi sederhana â€” cari layanan chat besar lebih dulu
  const pick =
    list.find(s => /llama|deepseek|qwen|mixtral/i.test(s.model)) ??
    list[0];

  const meta = await broker.inference.getServiceMetadata(pick.provider);
  return { providerAddress: pick.provider, endpoint: meta.endpoint, model: meta.model };
}

// Helper: acknowledge provider (idempotent di sisi kontrak)
async function ackProvider(broker: ZGComputeNetworkBroker, providerAddress: string) {
  await broker.inference.acknowledgeProviderSigner(providerAddress);
}

// Route: POST /api/og-chat
// Body JSON:
// {
//   "messages": [{ "role": "user"|"system"|"assistant", "content": "..." }, ...],
//   "providerAddress": "0x...",     // optional
//   "model": "llama-3.3-70b-instruct" // optional
// }
export async function POST(req: NextRequest) {
  try {
    const body = await req.json().catch(() => ({}));
    const messages: Array<{ role: "user" | "system" | "assistant"; content: string }> =
      body?.messages ?? [];
    if (!messages.length) {
      return NextResponse.json(
        { error: "messages[] is required" },
        { status: 400 }
      );
    }

    const preferredProvider: string | undefined =
      body?.providerAddress ?? OG_PROVIDER_ADDRESS ?? undefined;
    const preferredModel: string | undefined = body?.model ?? undefined;

    // 1) Init broker (koneksi 0G Chain via RPC + signer)
    const broker = await initBroker();

    // 2) Pastikan saldo cukup; auto-deposit bila kurang
    await ensureBalance(broker);

    // 3) Pilih service (provider + endpoint + model)
    const { providerAddress, endpoint, model } = await resolveService(
      broker,
      preferredProvider,
      preferredModel
    );

    // 4) Acknowledge provider on-chain (sekali per relasi; aman diulang)
    await ackProvider(broker, providerAddress);

    // 5) Buat headers otentikasi sekali-pakai untuk request ini
    //    Anda boleh gunakan "nonce" berbasis ringkasan prompt atau timestamp
    const nonce = messages[messages.length - 1]?.content?.slice(0, 64) || `nonce-${Date.now()}`;
    const authHeaders = await broker.inference.getRequestHeaders(providerAddress, nonce);

    // 6) Panggil endpoint provider gaya OpenAI
    const resp = await fetch(`${endpoint}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...authHeaders,
      },
      body: JSON.stringify({
        model, // dari metadata provider
        messages,
        // opsi lain yang biasanya didukung:
        // temperature: 0.7,
        // max_tokens: 1024,
        // stream: false
      }),
    });

    if (!resp.ok) {
      const t = await resp.text().catch(() => "");
      throw new Error(`Provider error ${resp.status}: ${t || resp.statusText}`);
    }

    const data = await resp.json();

    // 7) (Opsional) verifikasi hasil untuk layanan TEE
    //    Jika tidak TEE, ini akan tetap aman diabaikan
    let verified: boolean | undefined;
    try {
      verified = await broker.inference.processResponse(providerAddress, data);
    } catch {
      // abaikan verifikasi bila tidak tersedia
    }

    // 8) Ambil saldo terbaru untuk ditampilkan ke klien
    const acct = await broker.ledger.getLedger();

    return NextResponse.json({
      ok: true,
      providerAddress,
      model,
      verified: Boolean(verified),
      balance: acct.totalbalance.toString(),
      result: data, // struktur OpenAI-compatible
    });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json(
      { ok: false, error: err?.message ?? "Unknown error" },
      { status: 500 }
    );
  }
}
